+++
title = "Advanced"
description = "Advanced topics"
weight = 4
+++

## JavaScript interoperability

Trunk will create the necessary JavaScript code to bootstrap and run the WebAssembly based application. It will also
include all JavaScript snippets generated by `wasm-bindgen` for interfacing with JavaScript functionality.

By default, functions exported from Rust, using `wasm-bingen`, can be accessed in the JavaScript code through the global
variable `window.wasmBindings`. This behavior can be disabled, and the name can be customized. For more information
see the [`rust` asset type](@/assets.md#rust).

## Library crate

Aside from having a `main` function, it is also possible to up your project as a `cdylib` project. In order to do that,
add the following to your `Cargo.toml`:

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```

And then, define the entrypoint in your `lib.rs` like (does not need to be `async`):

```rust
#[wasm_bindgen(start)]
pub async fn run() {}
```

## Initializer

Since: `0.19.0-alpha.1`.

Trunk supports tapping into the initialization process of the WASM application. By
default, this is not active and works the same way as with previous versions.

The default process is that trunk injects a small JavaScript snippet, which imports the JavaScript loader generated
by `wasm_bindgen` and calls the `init` method. That will fetch the WASM blob and run it.

The downside with is, that during this process, there's no feedback to the user. Neither when it takes a bit longer to
load the WASM file, nor when something goes wrong.

Now it is possible to tap into this process by setting `data-initializer` to a JavaScript module file. This module file
is required to (default) export a function, which returns the "initializer" instance. Here is an example:

```javascript
export default function myInitializer () {
  return {
    onStart: () => {
      // called when the loading starts
    },
    onProgress: ({current, total}) => {
      // the progress while loading, will be called periodically.
      // "current" will contain the number of bytes of the WASM already loaded
      // "total" will either contain the total number of bytes expected for the WASM, or if the server did not provide
      //   the content-length header it will contain 0.
    },
    onComplete: () => {
      // called when the initialization is complete (successfully or failed)
    },
    onSuccess: (wasm) => {
      // called when the initialization is completed successfully, receives the `wasm` instance
    },
    onFailure: (error) => {
      // called when the initialization is completed with an error, receives the `error`
    }
  }
};
```

For a full example see: <https://github.com/trunk-rs/trunk/examples/initializer>.
